{"meta":{"title":"讀西概的工程師","subtitle":"用文字增加腦容量","description":"喜歡旅遊，標準狗派，喜歡為生活加點新花樣","author":"Debbie","url":"https://debbie8820.github.io","root":"/"},"pages":[],"posts":[{"title":"CS50 WEEK2-Arrays","slug":"CS50-WEEK2-Arrays","date":"2021-11-29T08:28:29.000Z","updated":"2021-11-30T05:02:11.616Z","comments":true,"path":"2021/11/29/CS50-WEEK2-Arrays/","link":"","permalink":"https://debbie8820.github.io/2021/11/29/CS50-WEEK2-Arrays/","excerpt":"","text":"第二周的主要重點圍繞在陣列，筆記主要分為以下六個區塊： 編譯過程 好用的除錯工具 宣告變數後存在哪裡? 記憶體簡介 陣列 Exit status 密碼學簡介 編譯經歷的比你想得更多當我們使用 make hello 將 source code 轉為 machine code 的時候，除了產生一個可執行的 hello 程式以外，會發現在螢幕上有一些看不懂的指令，如下圖： Clang 是我們所使用的編譯器(compiler)，它被安裝在CS50 IDE中，假設我們不能使用指令 make，也可以用 clang 進行編譯 1$ clang -o hello hello.c -lcs50 -o: output (輸出的檔名)-l: link (使用其他函式庫時要加入link, 告訴編譯器要去哪裡找function, 否則會報錯) 整段指令的意思是使用 Clang 編譯器，編譯後輸出的文件名稱取為 hello , 要進行編譯的文件則是 hello.c, 另外有使用到 cs50 函式庫 看似簡單的一行指令，事實上包含以下四個步驟： preprocessing 預處理 (C Preprocessor = CPP)預處理器會審視整份以 C 語言寫成的程式碼文件，檢查是否有語法或語義錯誤，並尋找有 # 記號的文字，像是 #include &lt;cs50.h&gt;，接著把 cs50.h 標頭檔(header file)的內容複製並貼到此文件中。 其他常見的預處理器指令可以參考 compiling 編譯將 preprocessor 輸出的內容轉換為 assembly code (組合語言，屬於低階語言，也可以說是電腦看得懂的語言) assembling 組譯 將 assembly code 轉換為 machine code ，機器語言，也就是由 0 和 1 所組成的二進位代碼，能夠讓電腦直接辨識，也可以稱它為目標代碼(object code)。 linking 連結 編譯的最後階段，連結器(linker)會將相關函式庫和其他程式產生的 object code (像是已轉換為 0 和 1 的 cs50.c, stdio.c)全部組裝在一起，成為一個可以執行的檔案 好用的除錯工具 printf 像是 JavaScript 裡面的 console.log() 一樣，可印出資料 使用方法：安插在你想確認的地點，確定程式運作是否如你預期 缺點是可能會打亂原本預期印出的樣子(e.g. 像是想印圖像會變成一種干擾) debug50 (一種 CS50 IDE 的指令) 平常程式的運作速度很快，很難找出問題出在哪，運用 debugger 可以為程式進行分解動作，查看哪一步有問題 使用方法：設定 breakpoint (停止點)，接著手動一步步看程式碼的執行狀況 debug50 ./hello 宣告變數後存在哪裡? 記憶體簡介RAM (Random Access Memory):當執行程式時，會需要在記憶體上面運作，屬於揮發性(Volatile)記憶體, 若停止供應電源，記憶體儲存的資料就會消失。 簡單複習一下 C 語言的基本資料型態及其占用大小 bool 1 byte char 1 byte double 8 bytes float 4 bytes int 4 bytes long 8 bytes 上圖中黃色圈起來的是晶片，內含 0 和 1 組成的資料，可以把它想像成網狀的樣子，一個格子代表一個byte， 如下圖所示(簡易版，實際有多少格子根據不同記憶體大小有所差異)，當今天宣告一個變數bool，就代表記憶體中某一個 byte 被這個 bool 拿去使用 陣列(Arrays)陣列是一種資料結構，內部可以儲存相同資料型態的變數。這樣做的好處是不需要宣告多個變數，可以全部放到陣列中。 在 C 語言中，宣告陣列時也要一併把陣列的長度也定義好： 1234int scores[3]; // 宣告時要定義長度scores[0] = 72;scores[1] = 73;scores[2] = 33; 上述程式碼也可以寫成 1int scores[3] = &#123;72, 73, 33&#125;; 計算學生成績的程式： 12345678910111213141516171819202122232425// scores.c#include &lt;stdio.h&gt;#include &lt;cs50.h&gt;int const TOTAL = 3; // 宣告常數，宣告後就無法更動值，通常習慣用大寫方便辨識int main(void)&#123; int scores[TOTAL]; for (int i = 0; i &lt; TOTAL; i++) &#123; scores[i] = get_int(&quot;What is your score?&quot;); &#125; printf(&quot;Average: %f\\n&quot;, average(TOTAL, scores));&#125;float average(int length, int array[])&#123; int sum = 0; for (int i = 0; i &lt; length; i++) &#123; sum += array[i] &#125; return sum / (float) length;;&#125; 宣告陣列時一定要宣告它的大小，但是如果要把某陣列傳給另一個功能(如上面例子將array傳給average function)，可以不用寫大小，寫arrays[ ]即可) 在average函式中，注意回傳的型態是float，但是array裡面放的都是int，如果將最後一行改成 return sum / length 會發現數字不精確(被truncate成integer)，要解決這個問題就是讓最後的計算過程至少包含一個浮點數，以本例來說就是將length也轉為浮點數再進行運算。 字串也是一種陣列? 假設今天想印出某個字母(char)的對應 ASCII CODE，可以這樣寫： 123456789#include &lt;stdio.h&gt;int main(void)&#123; char c = &#x27;#&#x27;; printf(&quot;%i\\n&quot;, c); //printf(&quot;%i\\n&quot;, (int) c)這樣寫也行&#125;// 35 在上述例子中，如果我們希望將 # 代表的ASCII code 印出來，可以使用 casting 的方式(也就是註解所示)，如果不用 casting 也可以，因為 # 算是電腦可以簡易得出ASCII code 的符號。 12345678910111213141516171819202122#include &lt;stdio.h&gt;int main(void)&#123; char c1 = &#x27;H&#x27;; char c2 = &#x27;I&#x27;; char c3 = &#x27;!&#x27;; printf(&quot;%i %i %i\\n&quot;, c1, c2, c3);&#125;// 72 73 33#include &lt;stdio.h&gt;int main(void)&#123; string c = &quot;HI!&quot;; printf(&quot;%s\\n&quot;, s);&#125;// HI! 在 C 語言中，並沒有 string 這種 data type, 這是另外被加到 CS50 library 裡面的，string 是 an array of chars，每個 char 都代表一個數字 (ASCII code)。在記憶體中 HI! 被存在一起，也因為它是一個陣列，所以我們有辦法存取內部任何位置的元素，像 s[0] = &#39;H&#39;, s[1] = &#39;I&#39; 記得前面提到過，宣告array時要一併宣告長度嗎? 既然 string 也是 array，為甚麼不用宣告長度? 原因是因為它在記憶體儲存的方式比較不同，以 HI! 這個字串來說，在記憶體會長這樣： 除了原本的字串以外，它還會多使用一個 byte 儲存 \\0 作為結束的標記，被稱作 null，整個字串總共會使用到 4 bytes，這也是為甚麼不用宣告長度但仍然能夠知道整個 string 在記憶體中已經結束了 轉為 ASCII code 會長這樣 下列程式碼可以印出字串對應的ASCII codes, 包含 null, 如果你想再印出接下來的字母也印的出來，像是s[4]，即使這個記憶體位置不屬於你該存取的範圍，這樣的特性如果沒有好好掌握可能會發生記憶體被無意竄改的意外 123456789// Prints string&#x27;s ASCII codes, including NUL#include &lt;cs50.h&gt;#include &lt;stdio.h&gt;int main(void)&#123; string s = &quot;HI!&quot;; printf(&quot;%i %i %i %i\\n&quot;, s[0], s[1], s[2], s[3]); &#125; &lt;補充&gt;在 C 語言中，單個字母要用單引號包住，一個字母以上則要用雙引號包住 下面例子希望可以印出使用者輸入的字串，在迴圈中，可以使用 i ≠ &#39;/0&#39; 作為迴圈進行的條件，這邊的 /0 會被當作一個字母(character)，因此要使用單引號 12345678910111213#include &lt;stdio.h&gt;#include &lt;cs50.h&gt;int main(void)&#123; string s = get_string(&quot;Input: &quot;); printf(&quot;Output: &quot;); for (int i = 0; i != &#x27;/0&#x27;; i++) &#123; printf(&quot;%c&quot;, s[i]); &#125; printf(&quot;/n&quot;);&#125; 也可以使用 strlen() 取得字串長度，這個方法被包含在 string.h 函式庫 1234567891011121314#include &lt;stdio.h&gt;#include &lt;cs50.h&gt;#include &lt;string.h&gt;int main(void)&#123; string s = get_string(&quot;Input: &quot;); printf(&quot;Output: &quot;); for (int i = 0, n = strlen(s); i &lt; n; i++) // 注意此行 &#123; printf(&quot;%c&quot;, s[i]); &#125; printf(&quot;/n&quot;);&#125; 注意第九行為什麼不寫成 for (int i = 0; i &lt; strlen(s); i++) 呢? 因為這樣的寫法等於是每跑一次for loop都要重新檢視 string length 是多少， i 是否小於它，不如一開始就把字串長度存在 n, 之後只要檢查 i 是否小於 n 就好 將字串轉為大寫： 12345678910111213141516171819202122// 自刻板#include &lt;stdio.h&gt;#include &lt;cs50.h&gt;#include &lt;string.h&gt;int main(void)&#123; string s = get_string(&quot;Before: &quot;); printf(&quot;After: &quot;); for (int i = 0, n = strlen(s); i &lt; n; i++) &#123; if (s[i] &gt;= &#x27;a&#x27; &amp;&amp; s[i] &lt;= &#x27;z&#x27;) &#123; printf(&quot;%c&quot;, s[i] - 32); &#125; else &#123; printf(&quot;%c&quot;, s[i]); &#125; &#125;&#125; 12345678910111213141516// 站在巨人肩膀版#include &lt;stdio.h&gt;#include &lt;cs50.h&gt;#include &lt;ctype.h&gt; // 加這行#include &lt;string.h&gt;int main(void)&#123; string s = get_string(&quot;Before: &quot;); printf(&quot;After: &quot;); for (int i = 0, n = strlen(s); i &lt; n; i++) &#123; printf(&quot;%c&quot;, toupper(s[i])); // 換這行 &#125;&#125; &lt;補充&gt;toupper 只能接受一個字母作為參數，因此必須搭配 for loop 才能讓所有字母轉為大寫 Command Arguments我們也能自己實作和 command line 類似的指令 以下例子在我們編譯完並輸入 ./argv debbie 時會印出 hello, debbie argc: argument count, argument 的總數 argv: argument vector, 裡面放所有argument 12345678910111213141516// print a command-line argument// argv0.c#include &lt;stdio.h&gt;#include &lt;cs50.h&gt;int main(int argc, string argv[])&#123; if (argc == 2) &#123; printf(&quot;hello, %s\\n&quot;, argv[1]); &#125; else &#123; printf(&quot;hello, world\\n&quot;); &#125;&#125; Exit Status最後解答 C 語言每次寫的 int main(void)&#123; ... &#125;這邊的 int 代表什麼呢？ 123456789101112131415// Returns explicit value from main// exit.c#include &lt;cs50.h&gt;#include &lt;stdio.h&gt;int main(int argc, string argv[])&#123; if (argc != 2) &#123; printf(&quot;Missing command-line argument\\n&quot;); return 1; &#125; printf(&quot;hello, %s\\n&quot;, argv[1]); return 0;&#125; C 程式在執行結束後會回傳一個整數，用來表示程式的結束狀態，程式執行成功時會回傳0，異常則回傳1，這也是為甚麼在主程式一開頭會看到 int 出現的原因。 那要如何得知 exit status 呢? 等程式執行完後在指令列輸入 echo $? 就能印出 exit status code Cryptography 密碼學簡介 plaintext + key ⇒ cipher ⇒ ciphertext 如同上面公式，透過加密，可以把一段訊息轉為一般人看不懂的訊息，網路通訊的過程常常應用這個技術，如此一來即使第三方中途劫持訊息，它也無法輕易得知訊息是什麼。 &lt;參考資料&gt;https://cs50.harvard.edu/x/2021/weeks/2/http://it-easy.tw/assembly-language/https://medium.datadriveninvestor.com/compilation-process-db17c3b58e62https://www.techonthenet.com/c_language/compiling_linking.php","categories":[{"name":"Tech","slug":"Tech","permalink":"https://debbie8820.github.io/categories/Tech/"}],"tags":[{"name":"C","slug":"C","permalink":"https://debbie8820.github.io/tags/C/"},{"name":"CS50","slug":"CS50","permalink":"https://debbie8820.github.io/tags/CS50/"},{"name":"Arrays","slug":"Arrays","permalink":"https://debbie8820.github.io/tags/Arrays/"}]}],"categories":[{"name":"Tech","slug":"Tech","permalink":"https://debbie8820.github.io/categories/Tech/"}],"tags":[{"name":"C","slug":"C","permalink":"https://debbie8820.github.io/tags/C/"},{"name":"CS50","slug":"CS50","permalink":"https://debbie8820.github.io/tags/CS50/"},{"name":"Arrays","slug":"Arrays","permalink":"https://debbie8820.github.io/tags/Arrays/"}]}