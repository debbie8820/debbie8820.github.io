{"meta":{"title":"讀西概的工程師","subtitle":"用文字增加腦容量","description":"喜歡旅遊，標準狗派，喜歡為生活加點新花樣","author":"Debbie","url":"https://debbie8820.github.io","root":"/"},"pages":[],"posts":[{"title":"CS50 WEEK2-Arrays","slug":"CS50-WEEK2-Arrays","date":"2021-11-18T08:28:29.000Z","updated":"2021-11-19T17:07:14.073Z","comments":true,"path":"2021/11/18/CS50-WEEK2-Arrays/","link":"","permalink":"https://debbie8820.github.io/2021/11/18/CS50-WEEK2-Arrays/","excerpt":"","text":"第二周的主要重點圍繞在陣列，筆記主要分為以下五個區塊： 編譯過程 好用的除錯工具 宣告變數後存在哪裡? 記憶體簡介 陣列 Exit status 密碼學簡介 編譯經歷的比你想得更多當我們使用 make hello 將 source code 轉為 machine code 的時候，除了產生一個可執行的 hello 程式以外，會發現在螢幕上有一些看不懂的指令，如下圖： Clang 是我們所使用的編譯器(compiler)，它被安裝在CS50 IDE中，假設我們不能使用指令 make，也可以用 clang 進行編譯 $ clang -o hello hello.c -lcs50 -o: output-l: link (使用其他函式庫時要加入link, 告訴編譯器要去哪裡找function, 否則會報錯) 整段指令的意思是使用 Clang 編譯器，編譯後輸出的文件名稱取為 hello, 要進行編譯的文件則是 hello.c, 另外有使用到 cs50 函式庫 看似簡單的一行指令，事實上包含以下四個步驟： preprocessing preprocessor會審視整份文件，尋找有#記號的文字，像是 #include &lt;cs50.h&gt;，把cs50.h文件的內容複製並貼到此文件中 compiling 將 C 語言寫成的程式碼轉換為 assembly code (電腦看得懂的語言) assembling 將 assembly code 轉換為 0 和 1 linking 將其他文件，像是已轉換為 0 和 1 的 cs50.c, stdio.c 程式碼全部組裝在一起，成為一個完整的程式 好用的除錯工具 printf 像是 JavaScript 裡面的 console.log() 一樣，可印出資料 使用方法：安插在你想確認的地點，確定程式運作是否如你預期 缺點是可能會打亂原本預期印出的樣子(e.g. 像是想印圖像會變成一種干擾) debug50 (一種 CS50 IDE 的指令) 平常程式的運作速度很快，很難找出問題出在哪，運用 debugger 可以為程式進行分解動作，查看哪一步有問題 使用方法：設定 breakpoint (停止點)，接著手動一步步看程式碼的執行狀況 debug50 ./hello 宣告變數後存在哪裡? 記憶體簡介RAM (Random Access Memory): volatile, 需要電力才能維持，當執行一個 C 語言程式時，會在記憶體上面運作 簡單複習一下 C 語言的基本資料型態及其占用大小 bool 1 byte char 1 byte double 8 bytes float 4 bytes int 4 bytes long 8 bytes 上圖中黃色圈起來的是晶片，內含 0 和 1 組成的資料，可以把它想像成網狀的樣子，一個格子代表一個byte， 如下圖所示(簡易版，實際有多少格子根據不同記憶體大小有所差異)，當今天宣告一個變數bool，就代表記憶體中某一個 byte 被這個 bool 拿去使用 陣列(Arrays)陣列是一種資料結構，內部可以儲存相同資料型態的變數。這樣做的好處是不需要宣告多個變數，可以全部放到陣列中。 在 C 語言中，宣告陣列時也要一併把陣列的長度也定義好： int scores[3]; // 宣告時要定義長度 scores[0] = 72; scores[1] = 73; scores[2] = 33; 上述程式碼也可以寫成 int scores[3] = &#123;72, 73, 33&#125;; 計算學生成績的程式： // scores.c #include &lt;stdio.h> #include &lt;cs50.h> int const TOTAL = 3; // 宣告常數，宣告後就無法更動值，通常習慣用大寫方便辨識 int main(void) &#123; int scores[TOTAL]; for (int i = 0; i &lt; TOTAL; i++) &#123; scores[i] = get_int(\"What is your score?\"); &#125; printf(\"Average: %f\\n\", average(TOTAL, scores)); &#125; float average(int length, int array[]) &#123; int sum = 0; for (int i = 0; i &lt; length; i++) &#123; sum += array[i] &#125; return sum / (float) length;; &#125; 宣告陣列時一定要宣告它的大小，但是如果要把某陣列傳給另一個功能(如上面例子將array傳給average function)，可以不用寫大小，寫arrays[ ]即可) 在average函式中，注意回傳的型態是float，但是array裡面放的都是int，如果將最後一行改成 return sum / length 會發現數字不精確(被truncate成integer)，要解決這個問題就是讓最後的計算過程至少包含一個浮點數，以本例來說就是將length也轉為浮點數再進行運算。 字串也是一種陣列? 假設今天想印出某個字母(char)的對應 ASCII CODE，可以這樣寫： #include &lt;stdio.h> int main(void) &#123; char c = '#'; printf(\"%i\\n\", c); //printf(\"%i\\n\", (int) c)這樣寫也行 &#125; // 35 在上述例子中，如果我們希望將#代表的ASCII code 印出來，可以使用 casting 的方式(也就是註解所示)，如果不用 casting 也可以，因為 # 算是電腦可以簡易得出ASCII code 的符號。 #include &lt;stdio.h> int main(void) &#123; char c1 = 'H'; char c2 = 'I'; char c3 = '!'; printf(\"%i %i %i\\n\", c1, c2, c3); &#125; // 72 73 33 #include &lt;stdio.h> int main(void) &#123; string c = \"HI!\"; printf(\"%s\\n\", s); &#125; // HI! 在 C 語言中，並沒有 string 這種 data type, 這是另外被加到 CS50 library 裡面的，string 就等於是 an array of chars，每個 char 都代表一個數字 (ASCII code)，在記憶體中HI!被存在一起，也因為它是一個陣列，所以我們有辦法存取內部任何位置的元素，像 s[0] = &#39;H&#39;, s[1] = &#39;I&#39; 記得前面提到過，宣告array時要一併宣告長度嗎? 既然 string 也是array，為甚麼不用宣告長度? 原因是因為它在記憶體儲存的方式比較不同，以 HI! 這個字串來說，在記憶體會長這樣： 轉為 ASCII code 會長這樣 以下程式碼可以印出字串對應的ASCII codes, 包含Null, 如果你想再印出接下來的字母也印的出來，像是 s[4]，即使這個記憶體位置已經不屬於你了 // Prints string's ASCII codes, including NUL #include &lt;cs50.h> #include &lt;stdio.h> int main(void) &#123; string s = \"HI!\"; printf(\"%i %i %i %i\\n\", s[0], s[1], s[2], s[3]); &#125; &lt;補充&gt; 在 C 語言中，單個字母要用單引號包住，一個字母以上則要用雙引號包住 下面例子希望可以印出使用者輸入的字串，在迴圈中，可以使用 i ≠ &#39;/0&#39; 作為迴圈進行的條件，這邊的 /0 會被當作一個字母(character)，因此要使用單引號 #include &lt;stdio.h&gt; #include &lt;cs50.h&gt; int main(void) &#123; string s &#x3D; get_string(&quot;Input: &quot;); printf(&quot;Output: &quot;); for (int i &#x3D; 0; i !&#x3D; &#39;&#x2F;0&#39;; i++) &#123; printf(&quot;%c&quot;, s[i]); &#125; printf(&quot;&#x2F;n&quot;); &#125; 也可以使用 strlen() 取得字串長度，這個方法被包含在 string.h 函式庫 #include &lt;stdio.h&gt; #include &lt;cs50.h&gt; #include &lt;string.h&gt; int main(void) &#123; string s &#x3D; get_string(&quot;Input: &quot;); printf(&quot;Output: &quot;); for (int i &#x3D; 0, n &#x3D; strlen(s); i &lt; n; i++) &#x2F;&#x2F; 注意此行 &#123; printf(&quot;%c&quot;, s[i]); &#125; printf(&quot;&#x2F;n&quot;); &#125; 於為什麼不寫成 for (int i = 0; i &lt; strlen(s); i++)，因為這樣的寫法等於是每跑一次for loop都要重新檢視 string length 是多少，i 是否小於它，不如一開始就把字串長度存在 n, 之後只要檢查 i 是否小於 n 就好 將字串轉為大寫 // 自刻板 #include &lt;stdio.h> #include &lt;cs50.h> #include &lt;string.h> int main(void) &#123; string s = get_string(\"Before: \"); printf(\"After: \"); for (int i = 0, n = strlen(s); i &lt; n; i++) &#123; if (s[i] >= 'a' &amp;&amp; s[i] &lt;= 'z') &#123; printf(\"%c\", s[i] - 32); &#125; else &#123; printf(\"%c\", s[i]); &#125; &#125; &#125; // 站在巨人肩膀版 #include &lt;stdio.h> #include &lt;cs50.h> #include &lt;ctype.h> // 加這行 #include &lt;string.h> int main(void) &#123; string s = get_string(\"Before: \"); printf(\"After: \"); for (int i = 0, n = strlen(s); i &lt; n; i++) &#123; printf(\"%c\", toupper(s[i])); // 換這行 &#125; &#125; toupper 只能接受一個字母，因此 for loop 是必要的 Command Arguments我們也能自己實作和command line 類似的指令 以下例子在我們編譯完並輸入 ./argv debbie 時會印出 hello, debbie argc: argument count, argument 的總數 argv: argument vector, 裡面放所有argument // print a command-line argument // argv0.c #include &lt;stdio.h> #include &lt;cs50.h> int main(int argc, string argv[]) &#123; if (argc == 2) &#123; printf(\"hello, %s\\n\", argv[1]); &#125; else &#123; printf(\"hello, world\\n\"); &#125; &#125; Exit Status最後解答 C 語言每次寫的 int main(void)&#123; ... &#125;這邊的 int 代表什麼呢？ // Returns explicit value from main // exit.c #include &lt;cs50.h> #include &lt;stdio.h> int main(int argc, string argv[]) &#123; if (argc != 2) &#123; printf(\"Missing command-line argument\\n\"); return 1; &#125; printf(\"hello, %s\\n\", argv[1]); return 0; &#125; 執行程式時，我們不會知道回傳的值是 1 還是 0，要取得exit status，我們必須等程式執行完後在指令列輸入 echo $?。錯誤訊息能夠協助開發者 Cyptography 密碼學plaintext + key ⇒ cipher ⇒ ciphertext 如同上面公式，透過加密，可以把一段訊息轉為一般人看不懂的訊息，網路通訊的過程常常應用這個技術，如此一來即使第三方中途劫持訊息，它也無法輕易得知訊息是什麼。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://debbie8820.github.io/categories/Tech/"}],"tags":[{"name":"C","slug":"C","permalink":"https://debbie8820.github.io/tags/C/"},{"name":"CS50","slug":"CS50","permalink":"https://debbie8820.github.io/tags/CS50/"},{"name":"Arrays","slug":"Arrays","permalink":"https://debbie8820.github.io/tags/Arrays/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-08-27T16:41:14.643Z","updated":"2021-08-27T16:41:14.643Z","comments":true,"path":"2021/08/28/hello-world/","link":"","permalink":"https://debbie8820.github.io/2021/08/28/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"Tech","slug":"Tech","permalink":"https://debbie8820.github.io/categories/Tech/"}],"tags":[{"name":"C","slug":"C","permalink":"https://debbie8820.github.io/tags/C/"},{"name":"CS50","slug":"CS50","permalink":"https://debbie8820.github.io/tags/CS50/"},{"name":"Arrays","slug":"Arrays","permalink":"https://debbie8820.github.io/tags/Arrays/"}]}