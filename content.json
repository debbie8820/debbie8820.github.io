{"posts":[{"title":"《原子時間》 Atomic Time 讀後筆記","text":"大多數人會把一週簡單分為「平日」和「週末」，也就是「工作日」和「非工作日」，這樣的想法會讓人把平日下班後的時間拿來等待週末，做一些無意義的事情，反而浪費了時間。事實上，你可以拿下班後的時間去做你想喜歡的事情。 當你認為時間綽綽有餘時，效率會降低，擁有很多自由時間反而需要更高的自制力。 此時幫自己設截止期限就是很好的推動力，像是平日晚上做事，固定上床時間。 💡 該如何填滿生活才不會後悔？ 為了生活，我們還是需要工作領薪水，但這不代表你不能同時追求其他事情，建立有效率、有時間意識感的晚間計畫，就是最好的方法。 比起問「幾點能下班？」，不如問自己「下班後做什麼？」 如何找出下班能做的事？ 選擇讓你有點小忙，但壓力較小的事 因為這是工作後要做的事情，如果壓力大容易做不下去，因此選擇的事情不必太有建設性，只要能讓眼睛為之一亮即可。像是看個電影、煮菜。從中獲得的資訊，可能是未來創造利潤的資源。 事先計算需要付出的時間和成本 針對有興趣的副業，先去做資料了解，推算自己是否能負荷時間費用，避免做白工。 先試試水溫，不適合要有放棄的勇氣 二、晚上改變了，早晨也會跟著改變有趣很好，有錢更好 藉由副業可以增加收入很棒，但能將下班後的自由時光過得有意義，即使賺不了錢、沒有人知道，也足以被視為非常有意義的時光。 培養成習慣最重要 下班後畫畫圖、健身，不管是為了興趣、健康或是小小業外收入，每天持續實踐才是最重要的，也因此我們需要設定目標。 三、晚間計畫的起點 💡 不要等待，時機永遠不會恰到好處 設定目標的前置作業 思考目標背後的意義 做事時光靠樂趣跟毅力是不夠的，比起注重目標的達成，去思考目標達成背後的意義和價值更為重要 e.g. 雖然作者認為擔任youtuber每次剪輯上字幕的過程很冗長且機械化，但他還是能夠堅持下去，原因是因為他想到這部影片會帶給很多人努力的動力，因此他能持續下去。 目標可以量化，意義賦予動能 很多人的目標會設定成今年要賺多少錢，當他們達成這個目標時，會維持短暫的快樂，隨後內心卻會感到空虛，這是因為他們只在意淺層的「目標」，沒有去思考背後帶來的意義。這樣很容易流於盲目追尋目標，無法達到內心實質的富足。 意義可以賦予動能，讓你克服過程中遇到的困難。 e.g. 作者在擔任獸醫時常常遇到機車主人，雖然覺得煩躁，但是只要想到這份工作能夠幫助到動物，他就有動力繼續做下去。 設定計畫四步驟 大目標 (這輩子或這兩年非常想要達成的計畫) 尋找意義 (意義賦予動能) 釐清方向 (要達成目標一定要做的事情) 行動方案 (為了完成方向而進行的小計畫) e.g. 使用曼陀羅計畫表把今年的終極目標寫上去，旁邊再圍繞八個小目標 達成目標的七個階段 設定目標 訂出期限 製作目標清單 擬定行動步驟 去除障礙 持續實踐 &amp; 修正 持續前進 訂下行動方案以後，專注在完成事項就可以了，焦點不用放在目標，因為只要把該做的事情做好，離目標自然會越來越近。 害怕猶豫時該怎麼辦? 💡 煩惱短一點，行動快一點 想像自己是排隊打針的人，當你看到前面的人打針後哀叫，此時你的恐懼感也會跟著變大。如果你是第一個打針的人，恐懼感反而還比較小。 恐懼感會隨著時間變大，但隨著行動而消除，因此當你覺得不安時，不如趕快開始行動才是解決之道，就算要擔心，也要給自己設定期限，如果因為擔心而遲遲不敢開始，反而會綁手綁腳，沒辦法做事。 克服擔心的方法： 問自己如果失敗的話是否會連累他人? 如果不會就趕快行動 給自己設定擔心的期限最多三天 把煩惱的原因用文字紀錄下來，很多時候煩惱產生都是因為感性，但用文字紀錄反而能幫助你用理性去思考，梳理情緒 四、建立高效的晚間計畫(上) 💡 人類最困難的事，就是了解自己並改變自己 (Alfred Adler) 為甚麼總是覺得沒時間? 無意識的放任時間流逝 首先要了解時間的特性，當你越在意它，它流動的速度就越慢。比方有三種情況人們覺得過的最久：等泡麵的時候、等退伍的時候和做平板式支撐的時候，相對來說，和朋友聊天或是逛街的時光總是特別快，因為你不會特別關注時間。 如果能養成習慣意識一天24小時，就能比別人多出很多時間。 常常做一些無關緊要的小事 比方上網看個影片傳個訊息，看起來很瑣碎的小時間，累積起來非常驚人。 要克服這種莫名其妙浪費時間的方式，就是每個半小時或一小時就檢視自己做了什麼，用回顧的方式記錄自己如何使用時間。 一天中你到底做了什麼? — 利用功能性筆記進行事後回顧 每小時回顧，找出高專注時段 紀錄一個月之後，大致能歸納出自己專注的時段有哪些，比方講者他白天體力最好，做勞力的事情效果很好，晚上則用來做創造力相關的事情。因此他白天運動，晚上則剪片或寫文章。照這樣的模式找出自己的節奏，就能有效運用時間。 制定晚間計畫表步驟 盤點空白時間 把每天能夠運用的空閒時間記錄下來，這邊有一點要特別注意，必須固定抽出的時間也要記錄並且從空閒時間扣除，比方帶狗狗散步或陪伴家人等。之所以要這樣做是為了避免在全力以赴做想做的事情時，錯過最基本且重要的小事。 了解時間成本和必須投入的專注度 評估每件事情要花費的時間。如果是第一次嘗試的東西，建議比預估多排1.5倍的時間，並持續修正。 製作晚間時刻表 把想做的事情依序填到計畫表中並開始執行。記住，時間表是為了幫助你管理時間而不是來囚禁你的，因此不用因為臨時有事無法執行計畫而感到有壓力，而是根據現況進行彈性調整。 不管過程遇到什麼困難，只要持續維持這個習慣，就能漸漸掌握時間。 其他方法：番茄鐘 避免浪費時間的技巧和心態 問題不再追劇，在於你有沒有充電 很多人會以為時間管理很好的人一定是不停的工作&amp;自我充實，也因此對時間管理的計畫感到壓力。 作者想提倡的時間倍增術，並不是將所有時間花在具有產能的事情上，工作和休息達到平衡才是作者希望大家達到的目標。 至於休息跟浪費時間該如何區分? 一個很簡單的原則：只要讓你有充電的感覺，那就是好的休息，比方同樣是放空，有人是在體力。 💡 管理時間最大的敵人並不是休息，而是無法好好休息，也無法好好工作，得過且過任憑時間流逝 五、建立高效的晚間計畫 (下) 意志力不是最關鍵的重點 培養重複性的節奏感很重要，在同樣的時間做同樣的事情，才能順勢形成習慣。因此可以把所有想養成習慣的事納入日常生活。 e.g. 每晚睡前半小時閱讀、睡前半小時做瑜珈，即使沒有意志力也可以完成。 訂晚間計畫的三大階段 一、建立小事 (簡單、好做) 二、每天同樣時間重複執行 三、堅守設定的時間 培養自己，不是一種比賽 有些事情必須燃燒精力去做，有些事情則需要慢慢享受，穩穩做下去。知道這個道理以後，會了解之所以有些事會中途放棄，就是因為一開始衝太快了，到後來無法駕馭。 思考像大人，行動像孩子 無論如何都要有趣 讓成果顯而易見 e.g. 利用 Habit Tracker 紀錄習慣 形象塑造，讓自己變成理想中的樣子 改變自我認知 人們對身邊的人多少有一點刻板印象，比方「那個人太善良了，一定老是被欺負」，我們對自己的認知也是如此，很多時候這些認知反而會限制我們的行為，彷彿像一個框架，覺得自己只能在框架下行動。 舉例，覺得自己沒有運動細胞的人就不太會去運動，並永遠停留在「我沒有運動細胞」的自我印象。 當一個人對自己的認知過於負面，周遭的人也容易被影響，比方認定你就是不會運動的人，未來有這樣的活動就不會找你。 你問我是誰？我是很厲害的人 要以正面的形象來定義自己，最有效的時機是「付出一點努力取得等值的小成功」之後，這是略帶吹噓的方式激勵自己最合理也最自在。 現在有些理論會告訴你，想成為XX人，要從潛意識告訴自己就是XX人，比方想變有錢人，就告訴自己已經是有錢人了，但作者認為「自我暗示」必須和「行動」相結合才有效果。 把自己當作小孩子看待，先做出小小成就 → 浮誇讚美自己 → 進而在腦中重塑自己的形象 → 當你的自我認知變正面了，未來下意識能做出符合自己的形象的決定。 六、想耍廢的時候怎麼辦：六種危機處理法 我只要有做一點點就好 有時可能會遇到下列情況，朋友有約、工作累不想繼續、一下班很想躺在床上，這時候該怎麼辦？直接延到明天，還是告訴自己做一點點就好，答案是後者，從過往的經驗可以知道，當你今天一旦放棄，明天絕對不會做事，而且會加倍不想做，因為人有惰性，當下讓自己放棄的藉口，明天會變得更加強大。 修正是為了走更遠 假設你的目標原本是每天跑 7 km，但你常常因為沒達標而想要放棄，那不如就把目標變成是每天有跑就好，不限定距離，當壓力變小時，腦袋自然會浮現想比昨天多跑一點的念頭。相反地，如果今天不想跑，就隨興的跑五分鐘也可以，只要能持續維持，有彈性的調整是沒問題的。 低潮期或無力感來襲時： 不是低潮，而是離峰期 之所以把低潮稱為離峰期，是因為語言帶來的意義與影響力很大。低潮會帶來無力以及負面的情緒，相對來說，既然有離峰，那就代表有尖峰的存在，也可以告訴自己只是暫時性地碰到熱度較低的時期，活力充沛的日子很快會再到來。 減少事情的份量 重點在於有彈性、有節奏的去駕馭低潮。大浪來襲時，不是捨命應戰，而是放掉力氣，適當融入，狀態不好的時候少做一點，告訴自己重點是不能放棄。 不要恐慌，充分休息 當低潮來襲，想減少事情的份量並休息時，就放輕鬆好好休息吧，不用覺得恐慌，如同前面提到的，能達到充電效果的休息就是好的休息，而不是空虛的度過時間。 得失心不要太重，目標只是方向鍵 常聽人說，想要實現夢想就要努力，但是努力不一定能實現夢想，當今天你已經盡力卻依然無法達成目標時，不用太過沮喪，盡人事聽天命，好好吸取這次的經驗，為下一次繼續努力，不要產生這次無法成功就想放棄一切的想法。目標只是指引你努力的方向，不是為了折磨現在的生活，最理想的狀態是，你的願望能變成可量化的目標，同時也能享受過程中把每個小行動完成的成就感。 反省演算法：避免過度自責和合理化 為甚麼沒有按照計畫執行？ 沒有辦法完成計畫的原因有很多種，試著去找出實際的原因，而不是單純覺得自己就是意志力不夠，比方影響意志力的原因可能是身體狀況不佳，天氣太熱，上班壓力大等，如果是身體不好，那就想辦法去改善身體狀況，比如多去運動等。 問題是否在於我無法駕馭？ 分析完為什麼沒有按照計畫進行的原因後，如果發現這個問題是我就算努力也無法改變，那就不用再想了，不需要為此過度糾結。 是否已盡了全力？ 筆者從 Marshall Goldsmith 的書 Trigger 學到很好的自省標準。訂出每天想實踐的幾種主題後，設計幾個問題自問自答以取得反饋，而每個問題的最後都必須以「我是否已經盡了全力？」作為結束 不要讓完美主義綁住你 不求做得好，但求做得久 我們要做的事情不像是開飛機、醫治生命，大部分都是可以容許出錯的，因此不要太糾結完美，只要記得每一次都可以慢慢修正，不求做得好，先求做得久，積少成多，累積屬於自己的能量。 意志力不夠時 行動力的養成，越自然越好 很多人覺得一定是意志力很強才會長期做一件事情，但問題其實不在行動力，而是行動力。實踐不需要強烈的意志，就只是做昨天做過的事和現在該做的事情而已。 與意志力相反，行動力的養成，盡可能越自然越好。 不要對所有事情卯足全力 從心靈層面來看，意志力和自律是綁在一起的，太常使用意志容易帶來壓力，反而會產生抗拒心理。因此如果不是跟人生有重大影響的事情，就帶著「沒什麼大不了」的心情去做吧。 在行動前或是行動期間都不要想太多，甚至是刻意想少一點，因為通常在行動前的想法常常會是負面的，像是我會不會做不好等，都還沒行動興致已經少一半了。 不被情緒綁架的方法就是即時察覺，在自我合理化以前即時行動。 💡 無論什麼事，感覺不想做之前必須趕快去做。 不要想「我果然沒有自制力！」，請改成「嗯，我又開始亂想了，不要想了，走吧！」 想放棄時，問自己三個問題放棄不是失敗，而是一種決定 多方嘗試後，剔除不適合的事，也是一種方法，特別是對「挑戰新手」來說，因為不太了解自己的喜好，嘗試不同的挑戰都是有意義的。 💡 反覆試錯、找路，是每個人必經的過程。 是否覺得不再開心 如果像是起身去做的前一刻覺得懶，試著忍耐一下，堅持看看。單純覺得麻煩的事，養成習慣之後就沒那麼難了。 長期來看，是否沒有正面成果 是否只對別人有好處，自己呢？ 如果做這件事沒辦法獲得任何樂趣、成就感，那果斷放棄也無妨。 不要在壓力大的時候做決定 不要當喪屍，管理體力的訣竅 運動 為了避免自己沒時間、太忙了的藉口，作者利用上班前的時間運動，一開始真的很累，很想睡，但撐過一兩個月後身體就習慣了。 兩個月定律 人是習慣的動物，撐過兩個月以後，就會慢慢維持住那個習慣的體力 吃得好，就是對自己好 陽光比 3C 重要 冥想","link":"/2021/12/05/AtomicTime/"},{"title":"CS50 WEEK2-Arrays","text":"第二周的主要重點圍繞在陣列，筆記主要分為以下六個區塊： 編譯過程 好用的除錯工具 宣告變數後存在哪裡? 記憶體簡介 陣列 Exit status 密碼學簡介 編譯經歷的比你想得更多當我們使用 make hello 將 source code 轉為 machine code 的時候，除了產生一個可執行的 hello 程式以外，會發現在螢幕上有一些看不懂的指令，如下圖： Clang 是我們所使用的編譯器(compiler)，它被安裝在CS50 IDE中，假設我們不能使用指令 make，也可以用 clang 進行編譯 1$ clang -o hello hello.c -lcs50 -o: output (輸出的檔名)-l: link (使用其他函式庫時要加入link, 告訴編譯器要去哪裡找function, 否則會報錯) 整段指令的意思是使用 Clang 編譯器，編譯後輸出的文件名稱取為 hello , 要進行編譯的文件則是 hello.c, 另外有使用到 cs50 函式庫 看似簡單的一行指令，事實上包含以下四個步驟： preprocessing 預處理 (C Preprocessor = CPP)預處理器會審視整份以 C 語言寫成的程式碼文件，檢查是否有語法或語義錯誤，並尋找有 # 記號的文字，像是 #include &lt;cs50.h&gt;，接著把 cs50.h 標頭檔(header file)的內容複製並貼到此文件中。 其他常見的預處理器指令可以參考 compiling 編譯將 preprocessor 輸出的內容轉換為 assembly code (組合語言，屬於低階語言，也可以說是電腦看得懂的語言) assembling 組譯 將 assembly code 轉換為 machine code ，機器語言，也就是由 0 和 1 所組成的二進位代碼，能夠讓電腦直接辨識，也可以稱它為目標代碼(object code)。 linking 連結 編譯的最後階段，連結器(linker)會將相關函式庫和其他程式產生的 object code (像是已轉換為 0 和 1 的 cs50.c, stdio.c)全部組裝在一起，成為一個可以執行的檔案 好用的除錯工具 printf 像是 JavaScript 裡面的 console.log() 一樣，可印出資料 使用方法：安插在你想確認的地點，確定程式運作是否如你預期 缺點是可能會打亂原本預期印出的樣子(e.g. 像是想印圖像會變成一種干擾) debug50 (一種 CS50 IDE 的指令) 平常程式的運作速度很快，很難找出問題出在哪，運用 debugger 可以為程式進行分解動作，查看哪一步有問題 使用方法：設定 breakpoint (停止點)，接著手動一步步看程式碼的執行狀況 debug50 ./hello 宣告變數後存在哪裡? 記憶體簡介RAM (Random Access Memory):當執行程式時，會需要在記憶體上面運作，屬於揮發性(Volatile)記憶體, 若停止供應電源，記憶體儲存的資料就會消失。 簡單複習一下 C 語言的基本資料型態及其占用大小 bool 1 byte char 1 byte double 8 bytes float 4 bytes int 4 bytes long 8 bytes 上圖中黃色圈起來的是晶片，內含 0 和 1 組成的資料，可以把它想像成網狀的樣子，一個格子代表一個byte， 如下圖所示(簡易版，實際有多少格子根據不同記憶體大小有所差異)，當今天宣告一個變數bool，就代表記憶體中某一個 byte 被這個 bool 拿去使用 陣列(Arrays)陣列是一種資料結構，內部可以儲存相同資料型態的變數。這樣做的好處是不需要宣告多個變數，可以全部放到陣列中。 在 C 語言中，宣告陣列時也要一併把陣列的長度也定義好： 1234int scores[3]; // 宣告時要定義長度scores[0] = 72;scores[1] = 73;scores[2] = 33; 上述程式碼也可以寫成 1int scores[3] = {72, 73, 33}; 計算學生成績的程式： 12345678910111213141516171819202122232425// scores.c#include &lt;stdio.h&gt;#include &lt;cs50.h&gt;int const TOTAL = 3; // 宣告常數，宣告後就無法更動值，通常習慣用大寫方便辨識int main(void){ int scores[TOTAL]; for (int i = 0; i &lt; TOTAL; i++) { scores[i] = get_int(&quot;What is your score?&quot;); } printf(&quot;Average: %f\\n&quot;, average(TOTAL, scores));}float average(int length, int array[]){ int sum = 0; for (int i = 0; i &lt; length; i++) { sum += array[i] } return sum / (float) length;;} 宣告陣列時一定要宣告它的大小，但是如果要把某陣列傳給另一個功能(如上面例子將array傳給average function)，可以不用寫大小，寫arrays[ ]即可) 在average函式中，注意回傳的型態是float，但是array裡面放的都是int，如果將最後一行改成 return sum / length 會發現數字不精確(被truncate成integer)，要解決這個問題就是讓最後的計算過程至少包含一個浮點數，以本例來說就是將length也轉為浮點數再進行運算。 字串也是一種陣列? 假設今天想印出某個字母(char)的對應 ASCII CODE，可以這樣寫： 123456789#include &lt;stdio.h&gt;int main(void){ char c = '#'; printf(&quot;%i\\n&quot;, c); //printf(&quot;%i\\n&quot;, (int) c)這樣寫也行}// 35 在上述例子中，如果我們希望將 # 代表的ASCII code 印出來，可以使用 casting 的方式(也就是註解所示)，如果不用 casting 也可以，因為 # 算是電腦可以簡易得出ASCII code 的符號。 12345678910111213141516171819202122#include &lt;stdio.h&gt;int main(void){ char c1 = 'H'; char c2 = 'I'; char c3 = '!'; printf(&quot;%i %i %i\\n&quot;, c1, c2, c3);}// 72 73 33#include &lt;stdio.h&gt;int main(void){ string c = &quot;HI!&quot;; printf(&quot;%s\\n&quot;, s);}// HI! 在 C 語言中，並沒有 string 這種 data type, 這是另外被加到 CS50 library 裡面的，string 是 an array of chars，每個 char 都代表一個數字 (ASCII code)。在記憶體中 HI! 被存在一起，也因為它是一個陣列，所以我們有辦法存取內部任何位置的元素，像 s[0] = 'H', s[1] = 'I' 記得前面提到過，宣告array時要一併宣告長度嗎? 既然 string 也是 array，為甚麼不用宣告長度? 原因是因為它在記憶體儲存的方式比較不同，以 HI! 這個字串來說，在記憶體會長這樣： 除了原本的字串以外，它還會多使用一個 byte 儲存 \\0 作為結束的標記，被稱作 null，整個字串總共會使用到 4 bytes，這也是為甚麼不用宣告長度但仍然能夠知道整個 string 在記憶體中已經結束了 轉為 ASCII code 會長這樣 下列程式碼可以印出字串對應的ASCII codes, 包含 null, 如果你想再印出接下來的字母也印的出來，像是s[4]，即使這個記憶體位置不屬於你該存取的範圍，這樣的特性如果沒有好好掌握可能會發生記憶體被無意竄改的意外 123456789// Prints string's ASCII codes, including NUL#include &lt;cs50.h&gt;#include &lt;stdio.h&gt;int main(void){ string s = &quot;HI!&quot;; printf(&quot;%i %i %i %i\\n&quot;, s[0], s[1], s[2], s[3]); } &lt;補充&gt;在 C 語言中，單個字母要用單引號包住，一個字母以上則要用雙引號包住 下面例子希望可以印出使用者輸入的字串，在迴圈中，可以使用 i ≠ '/0' 作為迴圈進行的條件，這邊的 /0 會被當作一個字母(character)，因此要使用單引號 12345678910111213#include &lt;stdio.h&gt;#include &lt;cs50.h&gt;int main(void){ string s = get_string(&quot;Input: &quot;); printf(&quot;Output: &quot;); for (int i = 0; i != '/0'; i++) { printf(&quot;%c&quot;, s[i]); } printf(&quot;/n&quot;);} 也可以使用 strlen() 取得字串長度，這個方法被包含在 string.h 函式庫 1234567891011121314#include &lt;stdio.h&gt;#include &lt;cs50.h&gt;#include &lt;string.h&gt;int main(void){ string s = get_string(&quot;Input: &quot;); printf(&quot;Output: &quot;); for (int i = 0, n = strlen(s); i &lt; n; i++) // 注意此行 { printf(&quot;%c&quot;, s[i]); } printf(&quot;/n&quot;);} 注意第九行為什麼不寫成 for (int i = 0; i &lt; strlen(s); i++) 呢? 因為這樣的寫法等於是每跑一次for loop都要重新檢視 string length 是多少， i 是否小於它，不如一開始就把字串長度存在 n, 之後只要檢查 i 是否小於 n 就好 將字串轉為大寫： 12345678910111213141516171819202122// 自刻板#include &lt;stdio.h&gt;#include &lt;cs50.h&gt;#include &lt;string.h&gt;int main(void){ string s = get_string(&quot;Before: &quot;); printf(&quot;After: &quot;); for (int i = 0, n = strlen(s); i &lt; n; i++) { if (s[i] &gt;= 'a' &amp;&amp; s[i] &lt;= 'z') { printf(&quot;%c&quot;, s[i] - 32); } else { printf(&quot;%c&quot;, s[i]); } }} 12345678910111213141516// 站在巨人肩膀版#include &lt;stdio.h&gt;#include &lt;cs50.h&gt;#include &lt;ctype.h&gt; // 加這行#include &lt;string.h&gt;int main(void){ string s = get_string(&quot;Before: &quot;); printf(&quot;After: &quot;); for (int i = 0, n = strlen(s); i &lt; n; i++) { printf(&quot;%c&quot;, toupper(s[i])); // 換這行 }} &lt;補充&gt;toupper 只能接受一個字母作為參數，因此必須搭配 for loop 才能讓所有字母轉為大寫 Command Arguments我們也能自己實作和 command line 類似的指令 以下例子在我們編譯完並輸入 ./argv debbie 時會印出 hello, debbie argc: argument count, argument 的總數 argv: argument vector, 裡面放所有argument 12345678910111213141516// print a command-line argument// argv0.c#include &lt;stdio.h&gt;#include &lt;cs50.h&gt;int main(int argc, string argv[]){ if (argc == 2) { printf(&quot;hello, %s\\n&quot;, argv[1]); } else { printf(&quot;hello, world\\n&quot;); }} Exit Status最後解答 C 語言每次寫的 int main(void){ ... }這邊的 int 代表什麼呢？ 123456789101112131415// Returns explicit value from main// exit.c#include &lt;cs50.h&gt;#include &lt;stdio.h&gt;int main(int argc, string argv[]){ if (argc != 2) { printf(&quot;Missing command-line argument\\n&quot;); return 1; } printf(&quot;hello, %s\\n&quot;, argv[1]); return 0;} C 程式在執行結束後會回傳一個整數，用來表示程式的結束狀態，程式執行成功時會回傳0，異常則回傳1，這也是為甚麼在主程式一開頭會看到 int 出現的原因。 那要如何得知 exit status 呢? 等程式執行完後在指令列輸入 echo $? 就能印出 exit status code Cryptography 密碼學簡介 plaintext + key ⇒ cipher ⇒ ciphertext 如同上面公式，透過加密，可以把一段訊息轉為一般人看不懂的訊息，網路通訊的過程常常應用這個技術，如此一來即使第三方中途劫持訊息，它也無法輕易得知訊息是什麼。 &lt;參考資料&gt;https://cs50.harvard.edu/x/2021/weeks/2/http://it-easy.tw/assembly-language/https://medium.datadriveninvestor.com/compilation-process-db17c3b58e62https://www.techonthenet.com/c_language/compiling_linking.php","link":"/2021/11/29/CS50-WEEK2-Arrays/"},{"title":"CS50 Pset2-Solutions Readability | Substitution","text":"本篇文章紀錄第二周的作業，分別是 Readability 和 Substitution，作業簡介如下，更詳細的規格可以點到連結觀看： 1. Readability Implement a program that computes the approximate grade level needed to comprehend some text, per the below.使用者會輸入一串文字，你必須根據提供的公式，利用字母數量、單字長度以及句數判斷出它的閱讀難易程度是多少。以下方例子來說，這段文字的程度為 3 級。 123$ ./readabilityText: Congratulations! Today is your day. You're off to Great Places! You're off and away!Grade 3 主要邏輯如下： 重點是先寫出一個能計算出字母數量，字數以及句數的程式。規格在作業說明都很清楚，需要補充的新知是如何一次回傳多個數值回主程式，這邊我使用 pointer 紀錄計算結果，pointer 在 C 語言能儲存某個變數的記憶體位置，將記憶體位置再傳給 analyze_text，取得記憶體位置後就能直接更改數值，達到跟回傳一樣的效果。 近似值，取最接近的整數在 C 語言中有很多種方法，分別是 round 和 lround：round: 將浮點數轉為最接近的整數並回傳浮點數。e.g. 5.8 =&gt; 5.0lround: 將浮點數轉為最接近的整數並回傳長整數(long int)。e.g. 5.8 =&gt; 5 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;stdio.h&gt;#include &lt;cs50.h&gt;#include &lt;ctype.h&gt;#include &lt;string.h&gt;#include &lt;math.h&gt;void analyze_text(string text, int *total_letters, int *total_words, int *total_sentences);int main(void){ string text = get_string(&quot;Text: &quot;); int total_letters, total_words, total_sentences, index; analyze_text(text, &amp;total_letters, &amp;total_words, &amp;total_sentences); float L = total_letters / (float)total_words * 100; float S = total_sentences / (float)total_words * 100; index = lround(0.0588 * L - 0.296 * S - 15.8); if (index &lt; 1) { printf(&quot;Before Grade 1\\n&quot;); } else if (index &gt;= 16) { printf(&quot;Grade 16+\\n&quot;); } else { printf(&quot;Grade %i\\n&quot;, index); }}void analyze_text(string text, int *total_letters, int *total_words, int *total_sentences){ int letters = 0; int words = 1; //The last word in a sentence int sentences = 0; for (int i = 0, n = strlen(text); i &lt; n; i++) { if ('a' &lt;= tolower(text[i]) &amp;&amp; tolower(text[i]) &lt;= 'z') { letters++; } else if (text[i] == ' ') { words++; } else if (text[i] == '.' || text[i] == '?' || text[i] == '!') { sentences++; } } *total_letters = letters; *total_words = words; *total_sentences = sentences;} 2. Substitution Implement a program that implements a substitution cipher, per the below.使用者會輸入一個由26個字母組成的字串作為key，你必須使用這個 key 為字串進行加密。以下方範例來說，字母 A 會被轉成 J, 以此類推，輸入輸出的大小寫必須保持一致。 123$ ./substitution JTREKYAVOGDXPSNCUIZLFBMWHQplaintext: HELLOciphertext: VKXXN 主要邏輯如下： 主程式會先檢查 argument 以及 key 的規格是否輸入正確，這邊要注意加密的 key 值裡面不能有重複，否則加密後無法得知原先的字是哪一個。 進行加密，跑迴圈確認字母是大寫或小寫，如果是字母是大寫那轉換的最後會再轉為大寫，反之亦然，如此就能維持保留字母的大小寫 將加密後的字串回傳並打印出來 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;stdio.h&gt;#include &lt;cs50.h&gt;#include &lt;string.h&gt;#include &lt;ctype.h&gt;string cipher(string plaintext, string key);int checkkey(string key);int main(int argc, string argv[]){ if (argc != 2) { printf(&quot;Usage: ./substitution key\\n&quot;); return 1; } if (checkkey(argv[1]) == 1) { return 1; } string plaintext = get_string(&quot;plaintext: &quot;); string ciphertext = cipher(plaintext, argv[1]); printf(&quot;ciphertext: %s\\n&quot;, ciphertext); return 0;}string cipher(string plaintext, string key){ for (int i = 0, n = strlen(plaintext); i &lt; n; i++) { if ('a' &lt;= plaintext[i] &amp;&amp; plaintext[i] &lt;= 'z') //如果原本是小寫最後會轉為小寫 { plaintext[i] = tolower(key[plaintext[i] - 'a']); } else if ('A' &lt;= plaintext[i] &amp;&amp; plaintext[i] &lt;= 'Z') //如果原本是大寫最後會轉為大寫 { plaintext[i] = toupper(key[plaintext[i] - 'A']); } } return plaintext;}int checkkey(string key){ if (strlen(key) != 26) // check length { printf(&quot;Key must contain 26 characters.\\n&quot;); return 1; } for (int i = 0, n = strlen(key); i &lt; n; i++) { if ('a' &gt; tolower(key[i]) || tolower(key[i]) &gt; 'z') // check invalid char { printf(&quot;Only alphabetic character is acceptable&quot;); return 1; } for (int j = i + 1; j &lt; n; j++) // check duplicates { if (key[j] == key[i]) { printf(&quot;Duplicate character is not acceptable, %c\\n&quot;, key[i]); return 1; } } } return 0;} 參考資料pointer https://www.guru99.com/c-pointers.htmllround https://www.delftstack.com/zh-tw/howto/c/round-function-in-c/","link":"/2021/12/03/CS50-Pset2/"},{"title":"從排序學演算法(1) — Selection Sort","text":"寫程式的時候，遇到排序問題常常都是直接呼叫built-in function來用，卻沒有真正去思考過它背後的演算法為何。這陣子面試剛好有被問到遇到排序的演算法，這才知道原來排序有這麼多種方法(怕XD)，決定用筆記的方式紀錄每個方法的差異。 首先從最直覺好懂的 Selection Sort 開始介紹 演算法的要點： 不斷比較數值大小並將數值小的元素放到未分類陣列的左邊 步驟： 找出未分類陣列中最小的元素 將最小的元素和最左邊的元素交換位置 接著從未分類陣列中再找出最小元素，並重複步驟 2，直到陣列排序完成 圖示解說：藍色方塊代表未分類元素綠色方塊代表已分類元素橘色方塊代表未分類陣列中最左邊元素或最小元素(已交換位置) 首先將整個陣列視為已分類(sorted subarray)以及未分類(unsorted subarray)陣列 陣列初始化為 const a = [50, 2, 31, 10, 67]，此時整個陣列都未分類。首先找出陣列中最小的元素並和未分類陣列(藍色)最左元素交換位置 以本例來說就是元素 2 和元素 50 互換位置 換完後元素 2 就變成已分類陣列(綠色)的一員，接著未分類陣列中最小的元素是 10，和元素 50 互換位置 未分類陣列中元素 31 最小，也剛好位於最左側元素，故保持不動 跟元素 31 一樣，元素 50 也維持不動 元素 67 也不動 此時整個陣列都變成綠色了，代表排序完成 程式碼： 12345678910111213141516const selectionSort = (arr) =&gt; { for(let i = 0; i &lt; arr.length; i++){ let minIndex = i for(let j = i + 1; j &lt; arr.length; j++){ //找出未分類陣列中最小的元素 if(arr[minIndex] &gt; arr[j]){ minIndex = j } } if(minIndex !== i){ let temp = arr[i] arr[i] = arr[minIndex] arr[minIndex] = temp } } console.log(arr)} 時間複雜度：O(n^2)空間複雜度：O(1) 以上就是 Selection Sort 的介紹，下一篇文章預計會介紹 Merge Sort！","link":"/2021/11/05/SelectionSort/"},{"title":"","text":"// const bubbleSort = (arr) => { // let totalSwaps = 0; // for (let i = 0; i < arr.length - 1; i++) { // if (i > 0 && totalSwaps === 0) break; //上一輪沒有任何元素互換，表示陣列已排序完畢，提早結束迴圈 // totalSwaps = 0; // for (let j = 0; j < arr.length - 1; j++) { // let temp; // if (arr[j] > arr[j + 1]) { // totalSwaps += 1; // temp = arr[j]; // arr[j] = arr[j + 1]; // arr[j + 1] = temp; // } // } // } // console.log(arr); // } // const array = [67, 14, 28, 2, 35]; // bubbleSort(array); ssh - o StrictHostKeyChecking = no root @$EC2_PUBLIC_IP \"cat ~/.ssh/id_rsa.pub | sed 's/^/\" /; s / $ / \"/'\") cat ~/.ssh/id_rsa.pub | sed 's/^/\" /; s / $ / \"/' '\"cat ~/.ssh/id_rsa.pub\"'","link":"/2022/02/06/Untitled-3/"},{"title":"演算法超簡介","text":"寫這篇文章主要是因為自己對資料結構不是太熟悉，故希望用文字的方式記錄一些常見的資料結構，當然之後還會再針對個別結構的實際應用詳細描述，本篇算是入門簡介。 什麼是資料結構?資料排序、儲存的方式，不同的資料結構會影響存取資料的難易程度，因此了解資料的結構與適合的場景才能幫助我們判斷寫程式時該使用什麼資料結構才能提高使用效率。 資料結構有哪些? Linked list 串列 線性的資料結構，由節點 (nodes) 組成，每個節點包含自己的數據 (data) 及一個指標 (pointer)，指標會指向下一個節點在記憶體中的位址，最後一個 node 的 pointer 會指向 null， 代表串列的終點，也因為有指標會記錄下個數據位置，因此每個節點在記憶體中不需要連續儲存。 特性： 存取數據時需要從頭跟著指標依序存取 (sequential access)，最多會花費 O(n) 的時間 增刪數據時只要把指標轉向即可，花費時間為 O(1) Array 陣列 陣列也屬於線性的資料結構，跟串列 (linked list)不同的是，陣列的數據是依序儲存在記憶體當中，因此可以使用索引 (index) 算出記憶體位址並直接存取數據，這又叫隨機存取 (random access)。 特性： 存取數據可以利用索引算出記憶體位址，直接存取數據，花費時間為 O(1) 增刪數據需要移動其他數據，比方今天要將一個元素插入陣列中第二個位置，首先要確認陣列最後面還有記憶體空間，接著把索引為 1 以後的元素全部往後挪一個位置，最後才能把新元素安插進去，最多會花費 O(n) 的時間。 queue 佇列 像是排隊的人潮一樣，先來的會優先處理，後來的則會排在隊伍的最後面，屬於先進先出(First In Last Out)的規範。 特性： 最舊的數據會優先被處理，假設要取中間的數據，跟堆疊一樣要先將在其之前的數據全部取出 (pop out)才能存取。 stack 堆疊 這種數據結構可以把它想像成堆疊盤子一樣，最早洗好的碗盤一定放在最下方，最晚洗好的則疊在最上方，如果要取盤子，要從最上方的開始拿，遵守後進先出 (Last In First Out)的規則。 特性： 存取數據必須從最上方的數據開始拿，假設要取中間的數據，要先將在其之上的數據全部取出 (pop out)才行。 hash table 雜湊表 雜湊表是用來儲存 key / value 這種成對數據的資料結構，利用雜湊函數 (hash table) 計算出所需數據在 Array 中的 index 是什麼，相較於使用 Array 進行搜索需要一個個尋找，時間複雜度為 O(n)，雜湊表平均搜索的時間可以到 O(1)。 💡 **key → HASH FUNCTION → array_index** 舉例來說，今天有個簡易的電話簿要存到陣列裡面，key 為人名，value 為電話，要儲存每個人名之前會先經過雜湊函數，計算出 index 值，再把 key / value 存到對應的陣列中 e.g. key: Debbie Index = hash function (Debbie) = 2 那假設今天計算出的 index 中已經有其他數據了怎麼辦呢？不同的 key 得出相同的雜湊值，這樣的情況我們稱之為碰撞 (Collision)，有兩種常見的解決方式，分別是鏈結法(Chaining) 和 Open Addressing, 鏈結法(Chaining)： 將同樣雜湊值的數據存成一個 linked list，這樣做後查找會變成線性搜尋，因此要注意 hash table 是否會造成太多碰撞，否則查找時間會跟 Array 相同。 開放定址法(Open addressing)： 當求出的位址已經存放數據時，再去尋找其他陣列中空缺的位置，至於怎麼查找也有多種方式 特性：因為有雜湊函數的幫助，查找時大幅減少搜索的時間，因為只要把 key 值丟到雜湊函數並得出 index, 就可以知道我們要找的值在 array 的某個 index 當中。不過也要注意陣列的規模選擇，規模太小容易發生碰撞，提高線性搜尋的情況，規模太大則會導致記憶體空間的浪費。 heap 堆積 堆積是二元樹結構的一種，意思是每個節點(node) 底下最多可以擁有兩個子節點，特性如下： 在最大堆積(max heap)，子節點的數值會比父節點小，最上面的節點(root)是最大的節點 在最小堆積(min heap)，子節點的數值會比父節點大，最上面的節點(root)是最小的節點 雖然稱它為二元樹的結構，但事實上它是個 Array，以上面 min heap 例子來解釋的話，它在 Array 的位置是從上到小、左到右排序在追加數據時，要將尾端數據和父節點比較並視情況調整位置，需要時間和樹的高度成正比，至於實際交換過程礙於篇幅限制會再寫一篇文章說明。 binary search tree 二元搜尋樹 所有節點都大於連結在其左邊的節點 所有節點都大於連結在其左邊的節點 從上述特性可以得知從最上面的節點往左邊走到最底會找到最小值，往右走到底則會是最大值 不論是在追加或是搜尋數據，都只要和當下的數據比較大小就可以決定該往左還是往右移動，執行時間也是和樹的高度成正比。實際比較的情況一樣會再新的文章中說明。 以上就是常見的資料結構簡單說明，對文章有任何想法歡迎留言交流！ 參考資料演算法圖鑑 https://www.notion.so/d757944b500a44c481f6b9c309297aad#e4ce1dd3d205441b998f6e6f09df9de1) Heap data structure https://www.notion.so/d757944b500a44c481f6b9c309297aad#949aae7627df4960a7df89d1bd59637e","link":"/2022/01/10/algorithm/"}],"tags":[{"name":"Time management","slug":"Time-management","link":"/tags/Time-management/"},{"name":"Reading","slug":"Reading","link":"/tags/Reading/"},{"name":"C","slug":"C","link":"/tags/C/"},{"name":"CS50","slug":"CS50","link":"/tags/CS50/"},{"name":"Arrays","slug":"Arrays","link":"/tags/Arrays/"},{"name":"Pointer","slug":"Pointer","link":"/tags/Pointer/"},{"name":"Solutions","slug":"Solutions","link":"/tags/Solutions/"},{"name":"Sorting","slug":"Sorting","link":"/tags/Sorting/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"JS","slug":"JS","link":"/tags/JS/"}],"categories":[{"name":"Reading","slug":"Reading","link":"/categories/Reading/"},{"name":"Tech","slug":"Tech","link":"/categories/Tech/"}],"pages":[]}