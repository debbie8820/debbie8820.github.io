{"meta":{"title":"讀西概的工程師","subtitle":"become a better me","description":"喜歡旅遊，標準狗派，喜歡為生活加點新花樣","author":"Debbie","url":"https://debbie8820.github.io","root":"/"},"pages":[],"posts":[{"title":"CS50 Pset2-Solutions Readability | Substitution","slug":"CS50-Pset2","date":"2021-12-03T04:02:14.000Z","updated":"2021-12-03T08:41:10.817Z","comments":true,"path":"2021/12/03/CS50-Pset2/","link":"","permalink":"https://debbie8820.github.io/2021/12/03/CS50-Pset2/","excerpt":"","text":"本篇文章紀錄第二周的作業，分別是 Readability 和 Substitution，作業簡介如下，更詳細的規格可以點到連結觀看： 1. Readability Implement a program that computes the approximate grade level needed to comprehend some text, per the below.使用者會輸入一串文字，你必須根據提供的公式，利用字母數量、單字長度以及句數判斷出它的閱讀難易程度是多少。以下方例子來說，這段文字的程度為 3 級。 123$ ./readabilityText: Congratulations! Today is your day. You&#x27;re off to Great Places! You&#x27;re off and away!Grade 3 主要邏輯如下： 重點是先寫出一個能計算出字母數量，字數以及句數的程式。規格在作業說明都很清楚，需要補充的新知是如何一次回傳多個數值回主程式，這邊我使用 pointer 紀錄計算結果，pointer 在 C 語言能儲存某個變數的記憶體位置，將記憶體位置再傳給 analyze_text，取得記憶體位置後就能直接更改數值，達到跟回傳一樣的效果。 近似值，取最接近的整數在 C 語言中有很多種方法，分別是 round 和 lround：round: 將浮點數轉為最接近的整數並回傳浮點數。e.g. 5.8 =&gt; 5.0lround: 將浮點數轉為最接近的整數並回傳長整數(long int)。e.g. 5.8 =&gt; 5 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;stdio.h&gt;#include &lt;cs50.h&gt;#include &lt;ctype.h&gt;#include &lt;string.h&gt;#include &lt;math.h&gt;void analyze_text(string text, int *total_letters, int *total_words, int *total_sentences);int main(void)&#123; string text = get_string(&quot;Text: &quot;); int total_letters, total_words, total_sentences, index; analyze_text(text, &amp;total_letters, &amp;total_words, &amp;total_sentences); float L = total_letters / (float)total_words * 100; float S = total_sentences / (float)total_words * 100; index = lround(0.0588 * L - 0.296 * S - 15.8); if (index &lt; 1) &#123; printf(&quot;Before Grade 1\\n&quot;); &#125; else if (index &gt;= 16) &#123; printf(&quot;Grade 16+\\n&quot;); &#125; else &#123; printf(&quot;Grade %i\\n&quot;, index); &#125;&#125;void analyze_text(string text, int *total_letters, int *total_words, int *total_sentences)&#123; int letters = 0; int words = 1; //The last word in a sentence int sentences = 0; for (int i = 0, n = strlen(text); i &lt; n; i++) &#123; if (&#x27;a&#x27; &lt;= tolower(text[i]) &amp;&amp; tolower(text[i]) &lt;= &#x27;z&#x27;) &#123; letters++; &#125; else if (text[i] == &#x27; &#x27;) &#123; words++; &#125; else if (text[i] == &#x27;.&#x27; || text[i] == &#x27;?&#x27; || text[i] == &#x27;!&#x27;) &#123; sentences++; &#125; &#125; *total_letters = letters; *total_words = words; *total_sentences = sentences;&#125; 2. Substitution Implement a program that implements a substitution cipher, per the below.使用者會輸入一個由26個字母組成的字串作為key，你必須使用這個 key 為字串進行加密。以下方範例來說，字母 A 會被轉成 J, 以此類推，輸入輸出的大小寫必須保持一致。 123$ ./substitution JTREKYAVOGDXPSNCUIZLFBMWHQplaintext: HELLOciphertext: VKXXN 主要邏輯如下： 主程式會先檢查 argument 以及 key 的規格是否輸入正確，這邊要注意加密的 key 值裡面不能有重複，否則加密後無法得知原先的字是哪一個。 進行加密，跑迴圈確認字母是大寫或小寫，如果是字母是大寫那轉換的最後會再轉為大寫，反之亦然，如此就能維持保留字母的大小寫 將加密後的字串回傳並打印出來 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;stdio.h&gt;#include &lt;cs50.h&gt;#include &lt;string.h&gt;#include &lt;ctype.h&gt;string cipher(string plaintext, string key);int checkkey(string key);int main(int argc, string argv[])&#123; if (argc != 2) &#123; printf(&quot;Usage: ./substitution key\\n&quot;); return 1; &#125; if (checkkey(argv[1]) == 1) &#123; return 1; &#125; string plaintext = get_string(&quot;plaintext: &quot;); string ciphertext = cipher(plaintext, argv[1]); printf(&quot;ciphertext: %s\\n&quot;, ciphertext); return 0;&#125;string cipher(string plaintext, string key)&#123; for (int i = 0, n = strlen(plaintext); i &lt; n; i++) &#123; if (&#x27;a&#x27; &lt;= plaintext[i] &amp;&amp; plaintext[i] &lt;= &#x27;z&#x27;) //如果原本是小寫最後會轉為小寫 &#123; plaintext[i] = tolower(key[plaintext[i] - &#x27;a&#x27;]); &#125; else if (&#x27;A&#x27; &lt;= plaintext[i] &amp;&amp; plaintext[i] &lt;= &#x27;Z&#x27;) //如果原本是大寫最後會轉為大寫 &#123; plaintext[i] = toupper(key[plaintext[i] - &#x27;A&#x27;]); &#125; &#125; return plaintext;&#125;int checkkey(string key)&#123; if (strlen(key) != 26) // check length &#123; printf(&quot;Key must contain 26 characters.\\n&quot;); return 1; &#125; for (int i = 0, n = strlen(key); i &lt; n; i++) &#123; if (&#x27;a&#x27; &gt; tolower(key[i]) || tolower(key[i]) &gt; &#x27;z&#x27;) // check invalid char &#123; printf(&quot;Only alphabetic character is acceptable&quot;); return 1; &#125; for (int j = i + 1; j &lt; n; j++) // check duplicates &#123; if (key[j] == key[i]) &#123; printf(&quot;Duplicate character is not acceptable, %c\\n&quot;, key[i]); return 1; &#125; &#125; &#125; return 0;&#125; 參考資料pointer https://www.guru99.com/c-pointers.htmllround https://www.delftstack.com/zh-tw/howto/c/round-function-in-c/","categories":[{"name":"Tech","slug":"Tech","permalink":"https://debbie8820.github.io/categories/Tech/"}],"tags":[{"name":"C","slug":"C","permalink":"https://debbie8820.github.io/tags/C/"},{"name":"CS50","slug":"CS50","permalink":"https://debbie8820.github.io/tags/CS50/"},{"name":"Pointer","slug":"Pointer","permalink":"https://debbie8820.github.io/tags/Pointer/"},{"name":"Solutions","slug":"Solutions","permalink":"https://debbie8820.github.io/tags/Solutions/"}]},{"title":"CS50 WEEK2-Arrays","slug":"CS50-WEEK2-Arrays","date":"2021-11-29T08:28:29.000Z","updated":"2021-11-30T05:02:11.616Z","comments":true,"path":"2021/11/29/CS50-WEEK2-Arrays/","link":"","permalink":"https://debbie8820.github.io/2021/11/29/CS50-WEEK2-Arrays/","excerpt":"","text":"第二周的主要重點圍繞在陣列，筆記主要分為以下六個區塊： 編譯過程 好用的除錯工具 宣告變數後存在哪裡? 記憶體簡介 陣列 Exit status 密碼學簡介 編譯經歷的比你想得更多當我們使用 make hello 將 source code 轉為 machine code 的時候，除了產生一個可執行的 hello 程式以外，會發現在螢幕上有一些看不懂的指令，如下圖： Clang 是我們所使用的編譯器(compiler)，它被安裝在CS50 IDE中，假設我們不能使用指令 make，也可以用 clang 進行編譯 1$ clang -o hello hello.c -lcs50 -o: output (輸出的檔名)-l: link (使用其他函式庫時要加入link, 告訴編譯器要去哪裡找function, 否則會報錯) 整段指令的意思是使用 Clang 編譯器，編譯後輸出的文件名稱取為 hello , 要進行編譯的文件則是 hello.c, 另外有使用到 cs50 函式庫 看似簡單的一行指令，事實上包含以下四個步驟： preprocessing 預處理 (C Preprocessor = CPP)預處理器會審視整份以 C 語言寫成的程式碼文件，檢查是否有語法或語義錯誤，並尋找有 # 記號的文字，像是 #include &lt;cs50.h&gt;，接著把 cs50.h 標頭檔(header file)的內容複製並貼到此文件中。 其他常見的預處理器指令可以參考 compiling 編譯將 preprocessor 輸出的內容轉換為 assembly code (組合語言，屬於低階語言，也可以說是電腦看得懂的語言) assembling 組譯 將 assembly code 轉換為 machine code ，機器語言，也就是由 0 和 1 所組成的二進位代碼，能夠讓電腦直接辨識，也可以稱它為目標代碼(object code)。 linking 連結 編譯的最後階段，連結器(linker)會將相關函式庫和其他程式產生的 object code (像是已轉換為 0 和 1 的 cs50.c, stdio.c)全部組裝在一起，成為一個可以執行的檔案 好用的除錯工具 printf 像是 JavaScript 裡面的 console.log() 一樣，可印出資料 使用方法：安插在你想確認的地點，確定程式運作是否如你預期 缺點是可能會打亂原本預期印出的樣子(e.g. 像是想印圖像會變成一種干擾) debug50 (一種 CS50 IDE 的指令) 平常程式的運作速度很快，很難找出問題出在哪，運用 debugger 可以為程式進行分解動作，查看哪一步有問題 使用方法：設定 breakpoint (停止點)，接著手動一步步看程式碼的執行狀況 debug50 ./hello 宣告變數後存在哪裡? 記憶體簡介RAM (Random Access Memory):當執行程式時，會需要在記憶體上面運作，屬於揮發性(Volatile)記憶體, 若停止供應電源，記憶體儲存的資料就會消失。 簡單複習一下 C 語言的基本資料型態及其占用大小 bool 1 byte char 1 byte double 8 bytes float 4 bytes int 4 bytes long 8 bytes 上圖中黃色圈起來的是晶片，內含 0 和 1 組成的資料，可以把它想像成網狀的樣子，一個格子代表一個byte， 如下圖所示(簡易版，實際有多少格子根據不同記憶體大小有所差異)，當今天宣告一個變數bool，就代表記憶體中某一個 byte 被這個 bool 拿去使用 陣列(Arrays)陣列是一種資料結構，內部可以儲存相同資料型態的變數。這樣做的好處是不需要宣告多個變數，可以全部放到陣列中。 在 C 語言中，宣告陣列時也要一併把陣列的長度也定義好： 1234int scores[3]; // 宣告時要定義長度scores[0] = 72;scores[1] = 73;scores[2] = 33; 上述程式碼也可以寫成 1int scores[3] = &#123;72, 73, 33&#125;; 計算學生成績的程式： 12345678910111213141516171819202122232425// scores.c#include &lt;stdio.h&gt;#include &lt;cs50.h&gt;int const TOTAL = 3; // 宣告常數，宣告後就無法更動值，通常習慣用大寫方便辨識int main(void)&#123; int scores[TOTAL]; for (int i = 0; i &lt; TOTAL; i++) &#123; scores[i] = get_int(&quot;What is your score?&quot;); &#125; printf(&quot;Average: %f\\n&quot;, average(TOTAL, scores));&#125;float average(int length, int array[])&#123; int sum = 0; for (int i = 0; i &lt; length; i++) &#123; sum += array[i] &#125; return sum / (float) length;;&#125; 宣告陣列時一定要宣告它的大小，但是如果要把某陣列傳給另一個功能(如上面例子將array傳給average function)，可以不用寫大小，寫arrays[ ]即可) 在average函式中，注意回傳的型態是float，但是array裡面放的都是int，如果將最後一行改成 return sum / length 會發現數字不精確(被truncate成integer)，要解決這個問題就是讓最後的計算過程至少包含一個浮點數，以本例來說就是將length也轉為浮點數再進行運算。 字串也是一種陣列? 假設今天想印出某個字母(char)的對應 ASCII CODE，可以這樣寫： 123456789#include &lt;stdio.h&gt;int main(void)&#123; char c = &#x27;#&#x27;; printf(&quot;%i\\n&quot;, c); //printf(&quot;%i\\n&quot;, (int) c)這樣寫也行&#125;// 35 在上述例子中，如果我們希望將 # 代表的ASCII code 印出來，可以使用 casting 的方式(也就是註解所示)，如果不用 casting 也可以，因為 # 算是電腦可以簡易得出ASCII code 的符號。 12345678910111213141516171819202122#include &lt;stdio.h&gt;int main(void)&#123; char c1 = &#x27;H&#x27;; char c2 = &#x27;I&#x27;; char c3 = &#x27;!&#x27;; printf(&quot;%i %i %i\\n&quot;, c1, c2, c3);&#125;// 72 73 33#include &lt;stdio.h&gt;int main(void)&#123; string c = &quot;HI!&quot;; printf(&quot;%s\\n&quot;, s);&#125;// HI! 在 C 語言中，並沒有 string 這種 data type, 這是另外被加到 CS50 library 裡面的，string 是 an array of chars，每個 char 都代表一個數字 (ASCII code)。在記憶體中 HI! 被存在一起，也因為它是一個陣列，所以我們有辦法存取內部任何位置的元素，像 s[0] = &#39;H&#39;, s[1] = &#39;I&#39; 記得前面提到過，宣告array時要一併宣告長度嗎? 既然 string 也是 array，為甚麼不用宣告長度? 原因是因為它在記憶體儲存的方式比較不同，以 HI! 這個字串來說，在記憶體會長這樣： 除了原本的字串以外，它還會多使用一個 byte 儲存 \\0 作為結束的標記，被稱作 null，整個字串總共會使用到 4 bytes，這也是為甚麼不用宣告長度但仍然能夠知道整個 string 在記憶體中已經結束了 轉為 ASCII code 會長這樣 下列程式碼可以印出字串對應的ASCII codes, 包含 null, 如果你想再印出接下來的字母也印的出來，像是s[4]，即使這個記憶體位置不屬於你該存取的範圍，這樣的特性如果沒有好好掌握可能會發生記憶體被無意竄改的意外 123456789// Prints string&#x27;s ASCII codes, including NUL#include &lt;cs50.h&gt;#include &lt;stdio.h&gt;int main(void)&#123; string s = &quot;HI!&quot;; printf(&quot;%i %i %i %i\\n&quot;, s[0], s[1], s[2], s[3]); &#125; &lt;補充&gt;在 C 語言中，單個字母要用單引號包住，一個字母以上則要用雙引號包住 下面例子希望可以印出使用者輸入的字串，在迴圈中，可以使用 i ≠ &#39;/0&#39; 作為迴圈進行的條件，這邊的 /0 會被當作一個字母(character)，因此要使用單引號 12345678910111213#include &lt;stdio.h&gt;#include &lt;cs50.h&gt;int main(void)&#123; string s = get_string(&quot;Input: &quot;); printf(&quot;Output: &quot;); for (int i = 0; i != &#x27;/0&#x27;; i++) &#123; printf(&quot;%c&quot;, s[i]); &#125; printf(&quot;/n&quot;);&#125; 也可以使用 strlen() 取得字串長度，這個方法被包含在 string.h 函式庫 1234567891011121314#include &lt;stdio.h&gt;#include &lt;cs50.h&gt;#include &lt;string.h&gt;int main(void)&#123; string s = get_string(&quot;Input: &quot;); printf(&quot;Output: &quot;); for (int i = 0, n = strlen(s); i &lt; n; i++) // 注意此行 &#123; printf(&quot;%c&quot;, s[i]); &#125; printf(&quot;/n&quot;);&#125; 注意第九行為什麼不寫成 for (int i = 0; i &lt; strlen(s); i++) 呢? 因為這樣的寫法等於是每跑一次for loop都要重新檢視 string length 是多少， i 是否小於它，不如一開始就把字串長度存在 n, 之後只要檢查 i 是否小於 n 就好 將字串轉為大寫： 12345678910111213141516171819202122// 自刻板#include &lt;stdio.h&gt;#include &lt;cs50.h&gt;#include &lt;string.h&gt;int main(void)&#123; string s = get_string(&quot;Before: &quot;); printf(&quot;After: &quot;); for (int i = 0, n = strlen(s); i &lt; n; i++) &#123; if (s[i] &gt;= &#x27;a&#x27; &amp;&amp; s[i] &lt;= &#x27;z&#x27;) &#123; printf(&quot;%c&quot;, s[i] - 32); &#125; else &#123; printf(&quot;%c&quot;, s[i]); &#125; &#125;&#125; 12345678910111213141516// 站在巨人肩膀版#include &lt;stdio.h&gt;#include &lt;cs50.h&gt;#include &lt;ctype.h&gt; // 加這行#include &lt;string.h&gt;int main(void)&#123; string s = get_string(&quot;Before: &quot;); printf(&quot;After: &quot;); for (int i = 0, n = strlen(s); i &lt; n; i++) &#123; printf(&quot;%c&quot;, toupper(s[i])); // 換這行 &#125;&#125; &lt;補充&gt;toupper 只能接受一個字母作為參數，因此必須搭配 for loop 才能讓所有字母轉為大寫 Command Arguments我們也能自己實作和 command line 類似的指令 以下例子在我們編譯完並輸入 ./argv debbie 時會印出 hello, debbie argc: argument count, argument 的總數 argv: argument vector, 裡面放所有argument 12345678910111213141516// print a command-line argument// argv0.c#include &lt;stdio.h&gt;#include &lt;cs50.h&gt;int main(int argc, string argv[])&#123; if (argc == 2) &#123; printf(&quot;hello, %s\\n&quot;, argv[1]); &#125; else &#123; printf(&quot;hello, world\\n&quot;); &#125;&#125; Exit Status最後解答 C 語言每次寫的 int main(void)&#123; ... &#125;這邊的 int 代表什麼呢？ 123456789101112131415// Returns explicit value from main// exit.c#include &lt;cs50.h&gt;#include &lt;stdio.h&gt;int main(int argc, string argv[])&#123; if (argc != 2) &#123; printf(&quot;Missing command-line argument\\n&quot;); return 1; &#125; printf(&quot;hello, %s\\n&quot;, argv[1]); return 0;&#125; C 程式在執行結束後會回傳一個整數，用來表示程式的結束狀態，程式執行成功時會回傳0，異常則回傳1，這也是為甚麼在主程式一開頭會看到 int 出現的原因。 那要如何得知 exit status 呢? 等程式執行完後在指令列輸入 echo $? 就能印出 exit status code Cryptography 密碼學簡介 plaintext + key ⇒ cipher ⇒ ciphertext 如同上面公式，透過加密，可以把一段訊息轉為一般人看不懂的訊息，網路通訊的過程常常應用這個技術，如此一來即使第三方中途劫持訊息，它也無法輕易得知訊息是什麼。 &lt;參考資料&gt;https://cs50.harvard.edu/x/2021/weeks/2/http://it-easy.tw/assembly-language/https://medium.datadriveninvestor.com/compilation-process-db17c3b58e62https://www.techonthenet.com/c_language/compiling_linking.php","categories":[{"name":"Tech","slug":"Tech","permalink":"https://debbie8820.github.io/categories/Tech/"}],"tags":[{"name":"C","slug":"C","permalink":"https://debbie8820.github.io/tags/C/"},{"name":"CS50","slug":"CS50","permalink":"https://debbie8820.github.io/tags/CS50/"},{"name":"Arrays","slug":"Arrays","permalink":"https://debbie8820.github.io/tags/Arrays/"}]}],"categories":[{"name":"Tech","slug":"Tech","permalink":"https://debbie8820.github.io/categories/Tech/"}],"tags":[{"name":"C","slug":"C","permalink":"https://debbie8820.github.io/tags/C/"},{"name":"CS50","slug":"CS50","permalink":"https://debbie8820.github.io/tags/CS50/"},{"name":"Pointer","slug":"Pointer","permalink":"https://debbie8820.github.io/tags/Pointer/"},{"name":"Solutions","slug":"Solutions","permalink":"https://debbie8820.github.io/tags/Solutions/"},{"name":"Arrays","slug":"Arrays","permalink":"https://debbie8820.github.io/tags/Arrays/"}]}